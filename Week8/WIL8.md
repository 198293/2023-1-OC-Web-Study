# Week8

[https://www.notion.so/Week8-fca91f7b97674d49a8c9cf4eab485884?pvs=4](https://www.notion.so/Week8-fca91f7b97674d49a8c9cf4eab485884)

[https://poiemaweb.com/](https://poiemaweb.com/)

[https://www.gdschongik.com/web-study/subject/8](https://www.gdschongik.com/web-study/subject/8)

# javascript

: 단순 정보 전달 + 정적인 웹사이트를 넘어서서 사용자가 프로그램처럼 하기 위해 만들어짐

**코드 실행 가능**

1. 상호 작용 가능
2. 데이터 송수신 가능
3. DOM 조정 가능

# 기본 문법

## 변수

: 메모리 공간에 이름을 붙여서 사용하는 것

→ 값을 할당하면 이름을 통해 그 값을 꺼내볼 수 있다.

→ 이름을 지어서 다양한 값을 넣어준다

### 특징

- **변수는 고정된 타입이 없다.**

→ 같은 변수에 여러 타입의 값을 자유롭게 할당할 수 있다.

- `v**ar` 키워드를 사용하여 변수를 선언하고, 할당 연산자 `=` 을 사용하여 변수에 값을 할당한다**
    - `var add1 = 10`
    - `var add1 = -1234`
    
    → 자바스크립트는 C나 Java외는 다르게 변수를 선언할 때 **데이터 타입을 미리 지정하지 않는다**.
    
    → 변수에 할당된 값의 타입에 의해 **동적으로 변수의 타입이 결정**된다.
    
    → 자바스크립트가 알아서 확보할 메모리 공간을 스스로 판단하는 것이다.
    
    (항상 좋은 것은 아니다. 프로그래밍 언어는 엄격하고 확실한 것을 좋아하기 때문에 번거롭더라도 c언어처럼 메모리를 명확하게 할당하는 것이 더 좋다.)
    

- **변수는 `variable`,`let`, `const` 키워드를 사용하여 선언하고 할당 연산자를 사용해 값을 할당한다.**
    
    → let은 재할당은 가능, 재선언은 불가능.
    
    → variable은 재할당 가능
    
    → const는 상수를 위해 사용. 선언과 동시에 할당이 이루어져야 한다. 재할당 불가능
    

## 연산자

- **피연산자의 타입은 반드시 일치할 필요는 없다.**

→  자바스크립트는 [**암묵적 타입 강제 변환**](https://poiemaweb.com/js-type-coercion#1-%EC%95%94%EB%AC%B5%EC%A0%81-%ED%83%80%EC%9E%85-%EA%B0%95%EC%A0%9C-%EB%B3%80%ED%99%98)을 통해 연산을 수행한다.

### symbol 연산자

: **변경 불가능한 원시 타입의 값**이다

→ 주로 이름의 충돌 위험이 없는 유일한 **객체의 프로퍼티 키(property key)**를 만들기 위해 사용한다

→ 심볼은 **Symbol 함수**를 호출해 생성한다

## 변수 호이스팅 **(Variable Hoisting)**

:  `var` 선언문이나 function 선언문 등 **모든 선언문이 해당 [Scope](https://poiemaweb.com/js-scope)의 선두로 옮겨진 것처럼 동작하는 특성**

→ 자바스크립트는 모든 선언문(var, let, const, function, [function*](https://poiemaweb.com/es6-generateor), class)이 선언되기 이전에 참조 가능하다.

## 단축 평가

| 단축 평가 표현식 | 평가 결과 |
| --- | --- |
| true || anything | true |
| false || anything | anything |
| true && anything | anything |
| false && anything | false |

## 프로토타입 객체

: 자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다. 이러한 부모 객체를 **Prototype(프로토타입) 객체** 또는 줄여서 Prototype(프로토타입)이라 한다.

→ Prototype 객체는 생성자 함수에 의해 생성된 각각의 객체에 **공유 프로퍼티를 제공하기 위해 사용**한다.

### 특징

- 프로토타입 기반 객체지향 프로그래밍 언어는 **클래스 없이(Class-less)도 객체를 생성**할 수 있다.
    
    (클래스 기반 객체지향 프로그래밍 언어는 객체 생성 이전에 클래스를 정의하고 이를 통해 객체(인스턴스)를 생성한다.)
    
- **자바스크립트의 모든 객체는 [[Prototype]]이라는 인터널 슬롯(internal slot)를 가진다.**
    
    → 모든 객체는 자신의 프로토타입 객체를 가리키는 [[Prototype]] 인터널 슬롯(internal slot) 을 갖으며 상속을 위해 사용된다.
    
- **[[Prototype]]의 값은 null 또는 객체이며 상속을 구현하는데 사용된다.**
    
    → **[[Prototype]] 객체의 데이터 프로퍼티는 get 액세스를 위해 상속**되어 **자식 객체의 프로퍼티처럼 사용**할 수 있다. 
    
- 프로토타입 객체는 **constructor 프로퍼티**를 갖는다
    
    → constructor 프로퍼티는 객체의 입장에서 **자신을 생성한 객체를 가리킨다**.
    

## ****[[Prototype]] vs prototype 프로퍼티****

: 함수 객체는 일반 객체와는 달리 **prototype 프로퍼티도 소유**하게 되는데, 이때 prototype 프로퍼티는 프로토타입 객체를 가리키는 [[Prototype]] 인터널 슬롯은 다르다

### prototype 프로퍼티

: **함수 객체**만 가지고 있는 프로퍼티이다.

→ **함수 객체가 생성자로 사용될 때 이 함수를 통해 생성될 객체의 부모 역할을 하는 객체(프로토타입 객체)를 가리킨다.**

### ****Prototype chain****

: 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 [[Prototype]]이 가리키는 링크를 따라 자신의 **부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다**

---

## 스코프(Scope, 유효범위)

: **참조 대상 식별자**(identifier, 변수, 함수의 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)**를 찾아내기 위한 규칙**

→ 스코프가 없다면 같은 식별자 이름은 충돌을 일으키므로 프로그램 전체에서 하나밖에 사용할 수 없다.

### 특징

- 자바스크립트는 **함수 레벨 스코프(function-level scope)**를 따른다
    
    → 함수 레벨 스코프란 함수 코드 블록 내에서 선언된 변수는 함수 코드 블록 내에서만 유효하고 함수 외부에서는 유효하지 않다(참조할 수 없다)는 것이다.
    

**전역 스코프 (Global scope)**

코드 어디에서든지 참조할 수 있다.

→ **전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이다**

**지역 스코프 (Local scope or Function-level scope)**

함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조할 수 있다.

→ **지역(자바스크립트의 경우 함수 내부)에서 선언된 변수는 지역 스코프를 갖는 지역 변수가 된다.**
